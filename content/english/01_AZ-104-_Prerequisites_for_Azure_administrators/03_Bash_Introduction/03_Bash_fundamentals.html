<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bash fundamentals - Training | Microsoft Learn</title>
<style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 30px 20px;
            color: #333;
            background-color: #fff;
        }
        
        h1, h2, h3, h4, h5, h6 {
            color: #0078d4;
            margin-top: 2em;
            margin-bottom: 1em;
            font-weight: 600;
        }
        
        h1 { 
            border-bottom: 3px solid #0078d4; 
            padding-bottom: 15px; 
            font-size: 2.2em;
            margin-bottom: 1.5em;
        }
        
        h2 { 
            font-size: 1.6em; 
            border-left: 4px solid #0078d4;
            padding-left: 15px;
        }
        
        h3 { font-size: 1.3em; }
        h4 { font-size: 1.1em; }
        
        p {
            margin: 16px 0;
            text-align: justify;
            line-height: 1.7;
        }
        
        ul, ol {
            margin: 20px 0;
            padding-left: 30px;
        }
        
        li {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        code {
            background-color: #f6f8fa;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            color: #d73a49;
        }
        
        pre {
            background-color: #f6f8fa;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #0078d4;
            margin: 20px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
            color: #333;
        }
        
        blockquote {
            border-left: 4px solid #0078d4;
            padding: 20px;
            margin: 20px 0;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-style: italic;
        }
        
        .source-info {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 5px solid #2196f3;
            font-size: 0.9em;
        }
        
        .source-info h2 {
            margin-top: 0;
            color: #1976d2;
            font-size: 1.2em;
        }
        
        .translation-placeholder {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 20px;
            border-radius: 8px;
            margin-top: 40px;
            border-left: 5px solid #ff9800;
        }
        
        .translation-placeholder h2 {
            margin-top: 0;
            color: #f57c00;
            font-size: 1.2em;
        }
        
        img { 
            max-width: 100%; 
            height: auto; 
            margin: 25px 0;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 25px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        th, td { 
            border: 1px solid #ddd; 
            padding: 15px; 
            text-align: left; 
        }
        
        th { 
            background-color: #f5f5f5; 
            font-weight: bold;
            color: #0078d4;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        
        strong {
            color: #0078d4;
            font-weight: 600;
        }
        
        a {
            color: #0078d4;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
<div class="source-info">
<h2>📚 Course Information</h2>
<p><strong>Unit:</strong> Bash fundamentals</p>
<p><strong>Source:</strong> <a href="https://learn.microsoft.com/en-us/training/modules/bash-introduction/2-bash-fundamentals/?ns-enrollment-type=learningpath&amp;ns-enrollment-id=learn.az104-admin-prerequisites" target="_blank">https://learn.microsoft.com/en-us/training/modules/bash-introduction/2-bash-fundamentals/?ns-enrollment-type=learningpath&amp;ns-enrollment-id=learn.az104-admin-prerequisites</a></p>
<p><strong>Course:</strong> AZ-104: Microsoft Azure Administrator</p>
</div>
<div class="main-content">
<div aria-hidden="false" id="module-unit-content">
<p>
  An understanding of Bash starts with an understanding of Bash syntax. After you know the syntax, you can apply it to every Bash command you run.
 </p>
<p>
  The full syntax for a Bash command is:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="command [options] [arguments]
"><span><span class="hljs-built_in">command</span> [options] [arguments]
</span></code></pre>
<p>
  Bash treats the first string it encounters as a command. The following command uses Bash's
  <code>
   ls
  </code>
  (for "list") command to display the contents of the current working directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls
"><span><span class="hljs-built_in">ls</span>
</span></code></pre>
<p>
  Arguments often accompany Bash commands. For example, you can include a path name in an
  <code>
   ls
  </code>
  command to list the contents of another directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls /etc
"><span><span class="hljs-built_in">ls</span> /etc
</span></code></pre>
<p>
  Most Bash commands have options for modifying how they work. Options, also called
  <em>
   flags
  </em>
  , give a command more specific instructions. As an example, files and directories whose names begin with a period are hidden from the user and aren't displayed by
  <code>
   ls
  </code>
  . However, you can include the
  <code>
   -a
  </code>
  (for "all") flag in an
  <code>
   ls
  </code>
  command and see everything in the target directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls -a /etc
"><span><span class="hljs-built_in">ls</span> -a /etc
</span></code></pre>
<p>
  You can even combine flags for brevity. For example, rather than enter
  <code>
   ls -a -l /etc
  </code>
  to show all files and directories in Linux's
  <strong>
   /etc
  </strong>
  directory in long form, you can enter this instead:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls -al /etc
"><span><span class="hljs-built_in">ls</span> -al /etc
</span></code></pre>
<p>
  Bash is concise. It's sometimes remarkable (and a point of pride among Bash aficionados) how much you can accomplish with a single command.
 </p>
<h2 id="get-help">
  Get help
 </h2>
<p>
  Which options and arguments can be used, or must be used, varies from command to command. Fortunately, Bash documentation is built into the operating system. Help is never more than a command away. To learn about the options for a command, use the
  <code>
   man
  </code>
  (for "manual") command. For instance, to see all the options for the
  <code>
   mkdir
  </code>
  ("make directory") command, do this:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="man mkdir
"><span>man <span class="hljs-built_in">mkdir</span>
</span></code></pre>
<p>
<code>
   man
  </code>
  is your best friend as you learn Bash.
  <code>
   man
  </code>
  is how you find the information you need to understand how any command works.
 </p>
<p>
  Most Bash and Linux commands support the
  <code>
   --help
  </code>
  option. This shows a description of the command's syntax and options. To demonstrate, enter
  <code>
   mkdir --help
  </code>
  . The output looks something like this:
 </p>
<pre class="has-inner-focus"><code class="lang-output" data-author-content="Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.
    
Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
    
GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;
Report mkdir translation bugs to &lt;http://translationproject.org/team/&gt;
Full documentation at: &lt;http://www.gnu.org/software/coreutils/mkdir&gt;
or available locally via: info '(coreutils) mkdir invocation'
">Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.
    
Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
    
GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;
Report mkdir translation bugs to &lt;http://translationproject.org/team/&gt;
Full documentation at: &lt;http://www.gnu.org/software/coreutils/mkdir&gt;
or available locally via: info '(coreutils) mkdir invocation'
</code></pre>
<p>
  Help obtained this way is typically more concise than help obtained with
  <code>
   man
  </code>
  .
 </p>
<h2 id="use-wildcards">
  Use wildcards
 </h2>
<p>
  Wildcards are symbols that represent one or more characters in Bash commands. The most frequently used wildcard is the asterisk. It represents zero characters or a sequence of characters. Suppose your current directory contains hundreds of image files, but you only want to see the PNG files; the ones whose file names end with
  <strong>
   .png
  </strong>
  . Here's the command to list only those files:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls *.png
"><span><span class="hljs-built_in">ls</span> *.png
</span></code></pre>
<div class="alert is-info">
<p class="alert-title">
   Note
  </p>
<p>
   Linux has no formal concept of a file-name extension as other operating systems do. This doesn't mean that PNG files won't have a
   <strong>
    .png
   </strong>
   extension. It simply means Linux attaches no special significance to the fact that the file names end with
   <strong>
    .png
   </strong>
   .
  </p>
</div>
<p>
  Now let's say the current directory also contains JPEG files. Some end in
  <strong>
   .jpg
  </strong>
  , while others end in
  <strong>
   .jpeg.
  </strong>
  Here's one way to list all the JPEG files:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls *.jpg *.jpeg
"><span><span class="hljs-built_in">ls</span> *.jpg *.jpeg
</span></code></pre>
<p>
  And here's another:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls *.jp*g
"><span><span class="hljs-built_in">ls</span> *.jp*g
</span></code></pre>
<p>
  The
  <code>
   *
  </code>
  wildcard matches on zero or more characters, but the
  <code>
   ?
  </code>
  wildcard represents a single character. If the current directory contains files named
  <strong>
   0001.jpg
  </strong>
  ,
  <strong>
   0002.jpg
  </strong>
  , and so on through
  <strong>
   0009.jpg
  </strong>
  , the following command lists them all:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls 000?.jpg
"><span><span class="hljs-built_in">ls</span> 000?.jpg
</span></code></pre>
<p>
  Yet another way to use wildcards to filter output is to use square brackets, which denote groups of characters. The following command lists all the files in the current directory whose names contain a period immediately followed a lowercase J or P. It lists all the
  <strong>
   .jpg
  </strong>
  ,
  <strong>
   .jpeg
  </strong>
  , and
  <strong>
   .png
  </strong>
  files, but not
  <strong>
   .gif
  </strong>
  files:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls *.[jp]*
"><span><span class="hljs-built_in">ls</span> *.[jp]*
</span></code></pre>
<p>
  In Linux, file names and the commands that operate upon them are case-sensitive. So to list all the files in the current directory whose names contain periods followed by an uppercase
  <em>
   or
  </em>
  lowercase J or P, you could enter this:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls *.[jpJP]*
"><span><span class="hljs-built_in">ls</span> *.[jpJP]*
</span></code></pre>
<p>
  Expressions in square brackets can represent ranges of characters. For example, the following command lists all the files in the current directory whose names begin with a lowercase letter:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls [a-z]*
"><span><span class="hljs-built_in">ls</span> [a-z]*
</span></code></pre>
<p>
  This command, by contrast, lists all the files in the current directory whose names begin with an uppercase letter:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls [A-Z]*
"><span><span class="hljs-built_in">ls</span> [A-Z]*
</span></code></pre>
<p>
  And this one lists all the files in the current directory whose names begin with a lowercase
  <em>
   or
  </em>
  uppercase letter:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls [a-zA-Z]*
"><span><span class="hljs-built_in">ls</span> [a-zA-Z]*
</span></code></pre>
<p>
  Based on all this, can you guess what the following commands do?
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls [0-9]*
ls *[0-9]*
ls *[0-9]
"><span><span class="hljs-built_in">ls</span> [0-9]*
<span class="hljs-built_in">ls</span> *[0-9]*
<span class="hljs-built_in">ls</span> *[0-9]
</span></code></pre>
<p>
  If you need to use one of the wildcard characters as an ordinary character, you make it literal or "escape it" by prefacing it with a backslash. So, if for some reason you had an asterisk as part of a file name—something you should never do intentionally—you could search for it by using a command such as:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="$ ls *\**
"><span>$ <span class="hljs-built_in">ls</span> *\**
</span></code></pre>
</div>
</div>
<div class="translation-placeholder">
<h2>🇻🇳 Vietnamese Translation</h2>
<div aria-hidden="false" id="module-unit-content-vi">
<p>
  Hiểu biết về Bash bắt đầu từ việc hiểu cú pháp Bash. Sau khi bạn biết cú pháp, bạn có thể áp dụng nó cho mọi lệnh Bash mà bạn chạy.
 </p>
<p>
  Cú pháp đầy đủ cho lệnh Bash là:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">command</span> [options] [arguments]
</span></code></pre>
<p>
  Bash coi chuỗi đầu tiên mà nó gặp là một lệnh. Lệnh sau sử dụng lệnh
  <code>
   ls
  </code>
  (viết tắt của "list") của Bash để hiển thị nội dung của thư mục làm việc hiện tại:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span>
</span></code></pre>
<p>
  Các argument thường đi kèm với lệnh Bash. Ví dụ, bạn có thể bao gồm tên đường dẫn trong lệnh
  <code>
   ls
  </code>
  để liệt kê nội dung của thư mục khác:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> /etc
</span></code></pre>
<p>
  Hầu hết các lệnh Bash đều có tùy chọn để sửa đổi cách chúng hoạt động. Các tùy chọn, còn được gọi là
  <em>
   flag
  </em>
  , cung cấp cho lệnh các hướng dẫn cụ thể hơn. Ví dụ, các file và thư mục có tên bắt đầu bằng dấu chấm được ẩn khỏi người dùng và không được hiển thị bởi
  <code>
   ls
  </code>
  . Tuy nhiên, bạn có thể bao gồm flag
  <code>
   -a
  </code>
  (viết tắt của "all") trong lệnh
  <code>
   ls
  </code>
  và xem mọi thứ trong thư mục đích:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> -a /etc
</span></code></pre>
<p>
  Bạn thậm chí có thể kết hợp các flag để ngắn gọn. Ví dụ, thay vì nhập
  <code>
   ls -a -l /etc
  </code>
  để hiển thị tất cả file và thư mục trong thư mục
  <strong>
   /etc
  </strong>
  của Linux ở dạng dài, bạn có thể nhập thay thế:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> -al /etc
</span></code></pre>
<p>
  Bash rất ngắn gọn. Đôi khi thật đáng chú ý (và là niềm tự hào của những người đam mê Bash) về việc bạn có thể hoàn thành bao nhiều việc với một lệnh duy nhất.
 </p>
<h2 id="get-help-vi">
  Nhận trợ giúp
 </h2>
<p>
  Những tùy chọn và argument nào có thể được sử dụng, hoặc phải được sử dụng, thay đổi từ lệnh này sang lệnh khác. May mắn thay, tài liệu Bash được tích hợp vào hệ điều hành. Trợ giúp không bao giờ cách xa hơn một lệnh. Để tìm hiểu về các tùy chọn cho một lệnh, sử dụng lệnh
  <code>
   man
  </code>
  (viết tắt của "manual"). Ví dụ, để xem tất cả các tùy chọn cho lệnh
  <code>
   mkdir
  </code>
  ("make directory"), làm như sau:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span>man <span class="hljs-built_in">mkdir</span>
</span></code></pre>
<p>
<code>
   man
  </code>
  là bạn tốt nhất khi bạn học Bash.
  <code>
   man
  </code>
  là cách bạn tìm thông tin cần thiết để hiểu cách bất kỳ lệnh nào hoạt động.
 </p>
<p>
  Hầu hết các lệnh Bash và Linux đều hỗ trợ tùy chọn
  <code>
   --help
  </code>
  . Điều này hiển thị mô tả về cú pháp và tùy chọn của lệnh. Để minh họa, nhập
  <code>
   mkdir --help
  </code>
  . Output trông giống như thế này:
 </p>
<pre class="has-inner-focus"><code class="lang-output">Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.
    
Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
</code></pre>
<p>
  Trợ giúp thu được theo cách này thường ngắn gọn hơn trợ giúp thu được với
  <code>
   man
  </code>
  .
 </p>
<h2 id="use-wildcards-vi">
  Sử dụng wildcard
 </h2>
<p>
  Wildcard là các ký hiệu đại diện cho một hoặc nhiều ký tự trong lệnh Bash. Wildcard được sử dụng thường xuyên nhất là dấu hoa thị. Nó đại diện cho không ký tự hoặc một chuỗi ký tự. Giả sử thư mục hiện tại của bạn chứa hàng trăm file hình ảnh, nhưng bạn chỉ muốn xem các file PNG; những file có tên kết thúc bằng
  <strong>
   .png
  </strong>
  . Đây là lệnh để chỉ liệt kê những file đó:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> *.png
</span></code></pre>
<div class="alert is-info">
<p class="alert-title">
   Lưu ý
  </p>
<p>
   Linux không có khái niệm chính thức về phần mở rộng tên file như các hệ điều hành khác. Điều này không có nghĩa là các file PNG sẽ không có phần mở rộng
   <strong>
    .png
   </strong>
   . Nó chỉ đơn giản có nghĩa là Linux không gắn ý nghĩa đặc biệt nào với việc tên file kết thúc bằng
   <strong>
    .png
   </strong>
   .
  </p>
</div>
<p>
  Bây giờ giả sử thư mục hiện tại cũng chứa các file JPEG. Một số kết thúc bằng
  <strong>
   .jpg
  </strong>
  , trong khi những file khác kết thúc bằng
  <strong>
   .jpeg.
  </strong>
  Đây là một cách để liệt kê tất cả các file JPEG:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> *.jpg *.jpeg
</span></code></pre>
<p>
  Và đây là cách khác:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> *.jp*g
</span></code></pre>
<p>
  Wildcard
  <code>
   *
  </code>
  khớp với không hoặc nhiều ký tự, nhưng wildcard
  <code>
   ?
  </code>
  đại diện cho một ký tự duy nhất. Nếu thư mục hiện tại chứa các file có tên
  <strong>
   0001.jpg
  </strong>
  ,
  <strong>
   0002.jpg
  </strong>
  , và cứ thế cho đến
  <strong>
   0009.jpg
  </strong>
  , lệnh sau liệt kê tất cả chúng:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> 000?.jpg
</span></code></pre>
<p>
  Một cách khác để sử dụng wildcard để lọc output là sử dụng dấu ngoặc vuông, biểu thị nhóm ký tự. Lệnh sau liệt kê tất cả các file trong thư mục hiện tại có tên chứa dấu chấm ngay sau đó là J hoặc P viết thường. Nó liệt kê tất cả các file
  <strong>
   .jpg
  </strong>
  ,
  <strong>
   .jpeg
  </strong>
  , và
  <strong>
   .png
  </strong>
  , nhưng không phải file
  <strong>
   .gif
  </strong>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> *.[jp]*
</span></code></pre>
<p>
  Trong Linux, tên file và các lệnh hoạt động trên chúng phân biệt chữ hoa chữ thường. Vì vậy, để liệt kê tất cả các file trong thư mục hiện tại có tên chứa dấu chấm theo sau bởi J hoặc P viết hoa
  <em>
   hoặc
  </em>
  viết thường, bạn có thể nhập:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> *.[jpJP]*
</span></code></pre>
<p>
  Các biểu thức trong dấu ngoặc vuông có thể đại diện cho phạm vi ký tự. Ví dụ, lệnh sau liệt kê tất cả các file trong thư mục hiện tại có tên bắt đầu bằng chữ cái viết thường:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> [a-z]*
</span></code></pre>
<p>
  Ngược lại, lệnh này liệt kê tất cả các file trong thư mục hiện tại có tên bắt đầu bằng chữ cái viết hoa:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> [A-Z]*
</span></code></pre>
<p>
  Và lệnh này liệt kê tất cả các file trong thư mục hiện tại có tên bắt đầu bằng chữ cái viết thường
  <em>
   hoặc
  </em>
  viết hoa:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> [a-zA-Z]*
</span></code></pre>
<p>
  Dựa trên tất cả điều này, bạn có thể đoán các lệnh sau làm gì không?
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span><span class="hljs-built_in">ls</span> [0-9]*
<span class="hljs-built_in">ls</span> *[0-9]*
<span class="hljs-built_in">ls</span> *[0-9]
</span></code></pre>
<p>
  Nếu bạn cần sử dụng một trong các ký tự wildcard như ký tự thông thường, bạn làm cho nó literal hoặc "escape nó" bằng cách đặt trước nó một dấu gạch chéo ngược. Vì vậy, nếu vì lý do nào đó bạn có dấu hoa thị như một phần của tên file—điều bạn không bao giờ nên làm có chủ ý—bạn có thể tìm kiếm nó bằng cách sử dụng lệnh như:
 </p>
<pre class="has-inner-focus"><code class="lang-bash"><span>$ <span class="hljs-built_in">ls</span> *\**
</span></code></pre>
</div>
</div>
</body>
</html>