<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bash commands and operators - Training | Microsoft Learn</title>
<style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 30px 20px;
            color: #333;
            background-color: #fff;
        }
        
        h1, h2, h3, h4, h5, h6 {
            color: #0078d4;
            margin-top: 2em;
            margin-bottom: 1em;
            font-weight: 600;
        }
        
        h1 { 
            border-bottom: 3px solid #0078d4; 
            padding-bottom: 15px; 
            font-size: 2.2em;
            margin-bottom: 1.5em;
        }
        
        h2 { 
            font-size: 1.6em; 
            border-left: 4px solid #0078d4;
            padding-left: 15px;
        }
        
        h3 { font-size: 1.3em; }
        h4 { font-size: 1.1em; }
        
        p {
            margin: 16px 0;
            text-align: justify;
            line-height: 1.7;
        }
        
        ul, ol {
            margin: 20px 0;
            padding-left: 30px;
        }
        
        li {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        code {
            background-color: #f6f8fa;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            color: #d73a49;
        }
        
        pre {
            background-color: #f6f8fa;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #0078d4;
            margin: 20px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
            color: #333;
        }
        
        blockquote {
            border-left: 4px solid #0078d4;
            padding: 20px;
            margin: 20px 0;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-style: italic;
        }
        
        .source-info {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 5px solid #2196f3;
            font-size: 0.9em;
        }
        
        .source-info h2 {
            margin-top: 0;
            color: #1976d2;
            font-size: 1.2em;
        }
        
        .translation-placeholder {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            padding: 20px;
            border-radius: 8px;
            margin-top: 40px;
            border-left: 5px solid #ff9800;
        }
        
        .translation-placeholder h2 {
            margin-top: 0;
            color: #f57c00;
            font-size: 1.2em;
        }
        
        img { 
            max-width: 100%; 
            height: auto; 
            margin: 25px 0;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 25px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        th, td { 
            border: 1px solid #ddd; 
            padding: 15px; 
            text-align: left; 
        }
        
        th { 
            background-color: #f5f5f5; 
            font-weight: bold;
            color: #0078d4;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        
        strong {
            color: #0078d4;
            font-weight: 600;
        }
        
        a {
            color: #0078d4;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
<div class="source-info">
<h2>ðŸ“š Course Information</h2>
<p><strong>Unit:</strong> Bash commands and operators</p>
<p><strong>Source:</strong> <a href="https://learn.microsoft.com/en-us/training/modules/bash-introduction/3-bash-commands/?ns-enrollment-type=learningpath&amp;ns-enrollment-id=learn.az104-admin-prerequisites" target="_blank">https://learn.microsoft.com/en-us/training/modules/bash-introduction/3-bash-commands/?ns-enrollment-type=learningpath&amp;ns-enrollment-id=learn.az104-admin-prerequisites</a></p>
<p><strong>Course:</strong> AZ-104: Microsoft Azure Administrator</p>
</div>
<div class="main-content">
<div aria-hidden="false" id="module-unit-content">
<p>
  Every shell language has its most-used commands. Let's start building your Bash repertoire by examining the most commonly used commands.
 </p>
<h2 id="bash-commands">
  Bash commands
 </h2>
<p>
  Let's look at common Bash commands and how to use them.
 </p>
<h3 id="ls-command">
<code>
   ls
  </code>
  command
 </h3>
<p>
<code>
   ls
  </code>
  lists the contents of your current directory or the directory specified in an argument to the command. By itself, it lists the files and directories in the current directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls
"><span><span class="hljs-built_in">ls</span>
</span></code></pre>
<p>
  Files and directories whose names begin with a period are hidden by default. To include these items in a directory listing, use an
  <code>
   -a
  </code>
  flag:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls -a
"><span><span class="hljs-built_in">ls</span> -a
</span></code></pre>
<p>
  To get even more information about the files and directories in the current directory, use an
  <code>
   -l
  </code>
  flag:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls -l
"><span><span class="hljs-built_in">ls</span> -l
</span></code></pre>
<p>
  Here's some sample output from a directory that contains a handful of JPEGs and PNGs and a subdirectory named
  <strong>
   gifs
  </strong>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-output" data-author-content="-rw-rw-r-- 1 azureuser azureuser  473774 Jun 13 15:38 0001.png
-rw-rw-r-- 1 azureuser azureuser 1557965 Jun 13 14:43 0002.jpg
-rw-rw-r-- 1 azureuser azureuser  473774 Mar 26 09:21 0003.png
-rw-rw-r-- 1 azureuser azureuser 4193680 Jun 13 09:40 0004.jpg
-rw-rw-r-- 1 azureuser azureuser  423325 Jun 10 12:53 0005.jpg
-rw-rw-r-- 1 azureuser azureuser 2278001 Jun 12 04:21 0006.jpg
-rw-rw-r-- 1 azureuser azureuser 1220517 Jun 13 14:44 0007.jpg
drwxrwxr-x 2 azureuser azureuser    4096 Jun 13 20:16 gifs
">-rw-rw-r-- 1 azureuser azureuser  473774 Jun 13 15:38 0001.png
-rw-rw-r-- 1 azureuser azureuser 1557965 Jun 13 14:43 0002.jpg
-rw-rw-r-- 1 azureuser azureuser  473774 Mar 26 09:21 0003.png
-rw-rw-r-- 1 azureuser azureuser 4193680 Jun 13 09:40 0004.jpg
-rw-rw-r-- 1 azureuser azureuser  423325 Jun 10 12:53 0005.jpg
-rw-rw-r-- 1 azureuser azureuser 2278001 Jun 12 04:21 0006.jpg
-rw-rw-r-- 1 azureuser azureuser 1220517 Jun 13 14:44 0007.jpg
drwxrwxr-x 2 azureuser azureuser    4096 Jun 13 20:16 gifs
</code></pre>
<p>
  Each line provides detailed information about the corresponding file or directory. That information includes the permissions assigned to it, its owner, its size in bytes, the last time it was modified, and the file or directory name.
 </p>
<h3 id="cat-command">
<code>
   cat
  </code>
  command
 </h3>
<p>
  Suppose you want to see what's inside a file. You can use the
  <code>
   cat
  </code>
  command for that. The output won't make much sense unless the file is a text file. The following command shows the contents of the
  <strong>
   os-release
  </strong>
  file stored in the
  <strong>
   /etc
  </strong>
  directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cat /etc/os-release
"><span>cat /etc/os-release
</span></code></pre>
<p>
  This is a useful command because it tells you which Linux distribution you're running:
 </p>
<pre class="has-inner-focus"><code class="lang-output" data-author-content='NAME="Ubuntu"
VERSION="18.04.2 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.2 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
'>NAME="Ubuntu"
VERSION="18.04.2 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.2 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
</code></pre>
<p>
  The
  <strong>
   /etc
  </strong>
  directory is a special one in Linux. It contains system-configuration files. You don't want to delete any files from this directory unless you know what you're doing.
 </p>
<h3 id="sudo-command">
<code>
   sudo
  </code>
  command
 </h3>
<p>
  Some Bash commands can only be run by the root user; a system administrator or superuser. If you try one of these commands without sufficient privileges, it fails. For example, only users logged in as a superuser can use
  <code>
   cat
  </code>
  to display the contents of
  <strong>
   /etc/at.deny
  </strong>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cat /etc/at.deny
"><span>cat /etc/at.deny
</span></code></pre>
<p>
<strong>
   at.deny
  </strong>
  is a special file that determines who can use other Bash commands to submit jobs for later execution.
 </p>
<p>
  You don't want to run as root most of the time; it's too dangerous. To run commands that require admin privilege without logging in as a superuser, you'll preface the commands with
  <code>
   sudo
  </code>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="sudo cat /etc/at.deny
"><span>sudo cat /etc/at.deny
</span></code></pre>
<p>
<code>
   sudo
  </code>
  stands for "superuser do." When you use it, you're telling the shell that for this one command, you're acting with the root-user level of permission.
 </p>
<h3 id="cd-mkdir-and-rmdir-commands">
<code>
   cd
  </code>
  ,
  <code>
   mkdir
  </code>
  , and
  <code>
   rmdir
  </code>
  commands
 </h3>
<p>
<code>
   cd
  </code>
  stands for "change directory," and it does exactly what the name suggests: it changes the current directory to another directory. It enables you to move from one directory to another just like its counterpart in Windows. The following command changes to a subdirectory of the current directory named
  <strong>
   orders
  </strong>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cd orders
"><span><span class="hljs-built_in">cd</span> orders
</span></code></pre>
<p>
  You can move up a directory by specifying
  <code>
   ..
  </code>
  as the directory name:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cd ..
"><span><span class="hljs-built_in">cd</span> ..
</span></code></pre>
<p>
  This command changes to your home directory; the one you land in when you first sign in:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cd ~
"><span><span class="hljs-built_in">cd</span> ~
</span></code></pre>
<p>
  You can create directories by using the
  <code>
   mkdir
  </code>
  command. The following command creates a subdirectory named
  <strong>
   orders
  </strong>
  in the current working directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="mkdir orders
"><span><span class="hljs-built_in">mkdir</span> orders
</span></code></pre>
<p>
  If you want to create a subdirectory and another subdirectory under it with one command, use the
  <code>
   --parents
  </code>
  flag:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="mkdir --parents orders/2019
"><span><span class="hljs-built_in">mkdir</span> --parents orders/2019
</span></code></pre>
<p>
  The
  <code>
   rmdir
  </code>
  command deletes (removes) a directory, but only if it's empty. If it's not empty, you get a warning instead. Fortunately, you can use the
  <code>
   rm
  </code>
  command to delete directories that aren't empty in combination with the
  <code>
   -r
  </code>
  (recursive) flag. The command would then look like so,
  <code>
   rm -r
  </code>
  .
 </p>
<h3 id="rm-command">
<code>
   rm
  </code>
  command
 </h3>
<p>
  The
  <code>
   rm
  </code>
  command is short for "remove." As you'd expect,
  <code>
   rm
  </code>
  deletes files. So this command puts an end to
  <strong>
   0001.jpg
  </strong>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="rm 0001.jpg
"><span>rm 0001.jpg
</span></code></pre>
<p>
  And this command deletes all the files in the current directory:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="rm *
"><span>rm *
</span></code></pre>
<p>
  Be wary of
  <code>
   rm
  </code>
  . It's a dangerous command.
 </p>
<p>
  Running
  <code>
   rm
  </code>
  with a
  <code>
   -i
  </code>
  flag lets you think before you delete:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="rm -i *
"><span>rm -i *
</span></code></pre>
<p>
  Make it a habit to include
  <code>
   -i
  </code>
  in every
  <code>
   rm
  </code>
  command, and you might avoid falling victim to one of Linux's biggest blunders. The dreaded
  <code>
   rm -rf /
  </code>
  command deletes every file on an entire drive. It works by recursively deleting all the subdirectories of root and their subdirectories. The
  <code>
   -f
  </code>
  (for "force") flag compounds the problem by suppressing prompts.
  <em>
   Don't do this.
  </em>
</p>
<p>
  If you want to delete a subdirectory named
  <strong>
   orders
  </strong>
  that isn't empty, you can use the
  <code>
   rm
  </code>
  command this way:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="rm -r orders
"><span>rm -r orders
</span></code></pre>
<p>
  This deletes the
  <strong>
   orders
  </strong>
  subdirectory and everything in it, including other subdirectories.
 </p>
<h3 id="cp-command">
<code>
   cp
  </code>
  command
 </h3>
<p>
  The
  <code>
   cp
  </code>
  command copies not just files, but entire directories (and subdirectories) if you want. To make a copy of
  <strong>
   0001.jpg
  </strong>
  named
  <strong>
   0002.jpg
  </strong>
  , use this command:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cp 0001.jpg 0002.jpg
"><span>cp 0001.jpg 0002.jpg
</span></code></pre>
<p>
  If
  <strong>
   0002.jpg
  </strong>
  already exists, Bash silently replaces it. That's great if it's what you intended, but not so wonderful if you didn't realize you were about to overwrite the old version.
 </p>
<p>
  Fortunately, if you use the
  <code>
   -i
  </code>
  (for "interactive") flag, Bash warns you before deleting existing files. This is safer:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cp -i 0001.jpg 0002.jpg
"><span>cp -i 0001.jpg 0002.jpg
</span></code></pre>
<p>
  You can use wildcards to copy several files at once. To copy all the files in the current directory to a subdirectory named
  <strong>
   photos
  </strong>
  , do this:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cp * photos
"><span>cp * photos
</span></code></pre>
<p>
  To copy all the files in a subdirectory named
  <strong>
   photos
  </strong>
  into a subdirectory named
  <strong>
   images
  </strong>
  , do this:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cp photos/* images
"><span>cp photos/* images
</span></code></pre>
<p>
  This assumes that the
  <strong>
   images
  </strong>
  directory already exists. If it doesn't, you can create it
  <em>
   and
  </em>
  copy the contents of the
  <strong>
   photos
  </strong>
  directory by using this command:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cp -r photos images
"><span>cp -r photos images
</span></code></pre>
<p>
  The
  <code>
   -r
  </code>
  stands for "recursive." An added benefit of the
  <code>
   -r
  </code>
  flag is that if
  <strong>
   photos
  </strong>
  contains subdirectories of its own, they too are copied to the
  <strong>
   images
  </strong>
  directory.
 </p>
<h3 id="ps-command">
<code>
   ps
  </code>
  command
 </h3>
<p>
  The
  <code>
   ps
  </code>
  command gives you a snapshot of all the currently running processes. By itself, with no arguments, it shows all your shell processes; in other words, not much. But it's a different story when you include a
  <code>
   -e
  </code>
  flag:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ps -e
"><span>ps -e
</span></code></pre>
<p>
<code>
   -e
  </code>
  lists
  <em>
   all
  </em>
  running processes, and there are typically many of them.
 </p>
<p>
  For a more comprehensive look at what processes are running in the system, use the
  <code>
   -ef
  </code>
  flag:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ps -ef 
"><span>ps -ef 
</span></code></pre>
<p>
  This flag shows the names of all the running processes, their process identification numbers (PIDs), the PIDs of their parents (PPIDs), and when they began (STIME). It also shows what terminal, if any, they're attached to (TTY), how much CPU time they've racked up (TIME), and their full path names. Here's an abbreviated example:
 </p>
<pre class="has-inner-focus"><code data-author-content="UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 13:35 ?        00:00:03 /sbin/init
root          2      0  0 13:35 ?        00:00:00 [kthreadd]
root          3      2  0 13:35 ?        00:00:00 [rcu_gp]
root          4      2  0 13:35 ?        00:00:00 [rcu_par_gp]
root          5      2  0 13:35 ?        00:00:00 [kworker/0:0-cgr]
root          6      2  0 13:35 ?        00:00:00 [kworker/0:0H-kb]
root          8      2  0 13:35 ?        00:00:00 [mm_percpu_wq]
root          9      2  0 13:35 ?        00:00:01 [ksoftirqd/0]
root         10      2  0 13:35 ?        00:00:02 [rcu_sched]
">UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 13:35 ?        00:00:03 /sbin/init
root          2      0  0 13:35 ?        00:00:00 [kthreadd]
root          3      2  0 13:35 ?        00:00:00 [rcu_gp]
root          4      2  0 13:35 ?        00:00:00 [rcu_par_gp]
root          5      2  0 13:35 ?        00:00:00 [kworker/0:0-cgr]
root          6      2  0 13:35 ?        00:00:00 [kworker/0:0H-kb]
root          8      2  0 13:35 ?        00:00:00 [mm_percpu_wq]
root          9      2  0 13:35 ?        00:00:01 [ksoftirqd/0]
root         10      2  0 13:35 ?        00:00:02 [rcu_sched]
</code></pre>
<p>
  As an aside, you might find documentation that shows
  <code>
   ps
  </code>
  being used this way:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ps aux
"><span>ps aux
</span></code></pre>
<p>
<code>
   ps aux
  </code>
  and
  <code>
   ps -ef
  </code>
  are the same. This duality traces back to historical differences between POSIX Unix systems (of which Linux is one) and BSD Unix systems (the most common of which is macOS). In the beginning, POSIX used
  <code>
   -ef
  </code>
  while the BSD required
  <code>
   aux
  </code>
  . Today, both operating-system families accept either format.
 </p>
<p>
  This serves as an excellent reminder of why you should look closely at the manual for all Linux commands. Learning Bash is like learning English as a second language. There are many exceptions to the rules.
 </p>
<h3 id="w-command">
<code>
   w
  </code>
  command
 </h3>
<p>
  Users come, users go, and sometimes you get users you don't want at all. When an employee leaves to pursue other opportunities, the sysadmin is called upon to ensure that the worker can no longer sign in to the company's computer systems. Sysadmins are also expected to know who's logged in, and who shouldn't be.
 </p>
<p>
  To find out who's on your servers, Linux provides the
  <code>
   w
  </code>
  (for "who") command. It displays information about the users currently on the computer system and those users' activities.
  <code>
   w
  </code>
  shows user names, their IP addresses, when they logged in, what processes they're currently running, and how much time those processes are consuming. It's a valuable tool for sysadmins.
 </p>
<h2 id="bash-io-operators">
  Bash I/O operators
 </h2>
<p>
  You can do a lot in Linux just by exercising Bash commands and their many options. But you can really get work done when you combine commands by using I/O operators:
 </p>
<ul>
<li>
<code>
    &lt;
   </code>
   for redirecting input to a source other than the keyboard
  </li>
<li>
<code>
    &gt;
   </code>
   for redirecting output to destination other than the screen
  </li>
<li>
<code>
    &gt;&gt;
   </code>
   for doing the same, but appending rather than overwriting
  </li>
<li>
<code>
    |
   </code>
   for piping output from one command to the input of another
  </li>
</ul>
<p>
  Suppose you want to list everything in the current directory but capture the output in a file named
  <strong>
   listing.txt
  </strong>
  . The following command does just that:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls &gt; listing.txt
"><span><span class="hljs-built_in">ls</span> &gt; listing.txt
</span></code></pre>
<p>
  If
  <strong>
   listing.txt
  </strong>
  already exists, it gets overwritten. If you use the
  <code>
   &gt;&gt;
  </code>
  operator instead, the output from
  <code>
   ls
  </code>
  is appended to what's already in
  <strong>
   listing.txt
  </strong>
  :
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ls &gt;&gt; listing.txt
"><span><span class="hljs-built_in">ls</span> &gt;&gt; listing.txt
</span></code></pre>
<p>
  The piping operator is powerful (and often used). It redirects the output of the first command to the input of the second command. Let's say you use
  <code>
   cat
  </code>
  to display the contents of a large file, but the content scrolls by too quickly for you to read. You can make the output more manageable by piping the results to another command such as
  <code>
   more
  </code>
  . The following command lists all the currently running processes. But once the screen is full, the output pauses until you select
  <strong>
   Enter
  </strong>
  to show the next line:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ps -ef | more
"><span>ps -ef | more
</span></code></pre>
<p>
  You can also pipe output to
  <code>
   head
  </code>
  to see just the first several lines:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ps -ef | head
"><span>ps -ef | head
</span></code></pre>
<p>
  Or suppose you want to filter the output to include only the lines that contain the word "daemon." One way to do that is by piping the output from
  <code>
   ps
  </code>
  to Linux's useful
  <code>
   grep
  </code>
  tool:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="ps -ef | grep daemon
"><span>ps -ef | grep daemon
</span></code></pre>
<p>
  The output might look like this:
 </p>
<pre aria-label="Horizontally scrollable code" class="has-inner-focus" role="group" tabindex="0"><code class="lang-output" data-author-content="azureus+  52463  50702  0 23:28 pts/0    00:00:00 grep --color=auto deamon
azureuser@bash-vm:~$ ps -ef | grep daemon
root        449      1  0 13:35 ?        00:00:17 /usr/lib/linux-tools/4.18.0-1018-azure/hv_kvp_daemon -n
root        988      1  0 13:35 ?        00:00:00 /usr/lib/accountsservice/accounts-daemon
message+   1002      1  0 13:35 ?        00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
daemon     1035      1  0 13:35 ?        00:00:00 /usr/sbin/atd -f
root       1037      1  0 13:35 ?        00:00:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root       1039      1  0 13:35 ?        00:00:00 /usr/lib/linux-tools/4.18.0-1018-azure/hv_vss_daemon -n
azureus+  52477  50702  0 23:28 pts/0    00:00:00 grep --color=auto daemon
">azureus+  52463  50702  0 23:28 pts/0    00:00:00 grep --color=auto deamon
azureuser@bash-vm:~$ ps -ef | grep daemon
root        449      1  0 13:35 ?        00:00:17 /usr/lib/linux-tools/4.18.0-1018-azure/hv_kvp_daemon -n
root        988      1  0 13:35 ?        00:00:00 /usr/lib/accountsservice/accounts-daemon
message+   1002      1  0 13:35 ?        00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
daemon     1035      1  0 13:35 ?        00:00:00 /usr/sbin/atd -f
root       1037      1  0 13:35 ?        00:00:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root       1039      1  0 13:35 ?        00:00:00 /usr/lib/linux-tools/4.18.0-1018-azure/hv_vss_daemon -n
azureus+  52477  50702  0 23:28 pts/0    00:00:00 grep --color=auto daemon
</code></pre>
<p>
  You can also use files as input. By default, standard input comes from the keyboard, but it too can be redirected. To get input from a file instead of the keyboard, use the
  <code>
   &lt;
  </code>
  operator. One common sysadmin task is to sort the contents of a file. As the name suggests,
  <code>
   sort
  </code>
  sorts text in alphabetical order:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="sort &lt; file.txt
"><span>sort &lt; file.txt
</span></code></pre>
<p>
  To save the sorted results to a new file, you can redirect input
  <em>
   and
  </em>
  output:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="sort &lt; file.txt &gt; sorted_file.txt
"><span>sort &lt; file.txt &gt; sorted_file.txt
</span></code></pre>
<p>
  You can use I/O operators to chain Linux commands as needed. Consider the following command:
 </p>
<pre class="has-inner-focus"><code class="lang-bash" data-author-content="cat file.txt | fmt | pr | lpr
"><span>cat file.txt | fmt | pr | lpr
</span></code></pre>
<p>
  The output from
  <code>
   cat
  </code>
  goes to
  <code>
   fmt
  </code>
  , the output from
  <code>
   fmt
  </code>
  goes to
  <code>
   pr
  </code>
  , and so on.
  <code>
   fmt
  </code>
  formats the results into a tidy paragraph.
  <code>
   pr
  </code>
  paginates the results. And
  <code>
   lpr
  </code>
  sends the paginated output to the printer. All in a single line!
 </p>
</div>
</div>
<div class="translation-placeholder">
<h2>ðŸ‡»ðŸ‡³ Vietnamese Translation</h2>
<p><em>Báº£n dá»‹ch tiáº¿ng Viá»‡t sáº½ Ä‘Æ°á»£c thÃªm vÃ o Ä‘Ã¢y...</em></p>
<p><em>Translation will be added here...</em></p>
</div>
</body>
</html>